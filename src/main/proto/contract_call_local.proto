syntax = "proto3";

package proto;

/*-
 * ‌
 * Hedera Network Services Protobuf
 * ​
 * Copyright (C) 2018 - 2021 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

option java_package = "com.hederahashgraph.api.proto.java";
option java_multiple_files = true;

import "basic_types.proto";
import "query_header.proto";
import "response_header.proto";

/**
 * The log information for an event returned by a smart contract function call. One function call
 * may return several such events.
 */
message ContractLoginfo {
    /**
     * address of a contract that emitted the event
     */
    ContractID contractID = 1;

    /**
     * bloom filter for a particular log
     */
    bytes bloom = 2;

    /**
     * topics of a particular event
     */
    repeated bytes topic = 3;

    /**
     * event data
     */
    bytes data = 4;
}

/**
 * The result returned by a call to a smart contract function. This is part of the response to a
 * ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
 * transaction. The ContractCreateInstance transaction record has the results of the call to the
 * constructor.
 */
message ContractFunctionResult {
    /**
     * the smart contract instance whose function was called
     */
    ContractID contractID = 1;

    /**
     * the result returned by the function
     */
    bytes contractCallResult = 2;

    /**
     * message In case there was an error during smart contract execution
     */
    string errorMessage = 3;

    /**
     * bloom filter for record
     */
    bytes bloom = 4;

    /**
     * units of gas used to execute contract
     */
    uint64 gasUsed = 5;

    /**
     * the log info for events returned by the function
     */
    repeated ContractLoginfo logInfo = 6;

    /**
     * the list of smart contracts that were created by the function call
     */
    repeated ContractID createdContractIDs = 7;

    /**
     * the list of actions that occurred within this function call
     */
    repeated ContractAction actions = 8;

    /**
     * the list of state reads and changes caused by this function call
     */
    repeated ContractStateChange stateChanges = 9;

}

/**
 * Call a function of the given smart contract instance, giving it functionParameters as its inputs.
 * This is performed locally on the particular node that the client is communicating with.
 * It cannot change the state of the contract instance (and so, cannot spend anything from the instance's cryptocurrency account).
 * It will not have a consensus timestamp. It cannot generate a record or a receipt. The response will contain the output
 * returned by the function call.  This is useful for calling getter functions, which purely read the state and don't change it.
 * It is faster and cheaper than a normal call, because it is purely local to a single  node.
 * 
 * Unlike a ContractCall transaction, the node will consume the entire amount of provided gas in determining
 * the fee for this query.
 */
message ContractCallLocalQuery {
    /**
     * standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered.
     */
    QueryHeader header = 1;

    /**
     * the contract instance to call, in the format used in transactions
     */
    ContractID contractID = 2;

    /**
     * The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee
     */
    int64 gas = 3;

    /**
     * which function to call, and the parameters to pass to the function
     */
    bytes functionParameters = 4;

    /**
     * max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.
     */
    int64 maxResultSize = 5;
}

/**
 * Response when the client sends the node ContractCallLocalQuery
 */
message ContractCallLocalResponse {
    /**
     * standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
     */
    ResponseHeader header = 1;

    /**
     * the value returned by the function (if it completed and didn't fail)
     */
    ContractFunctionResult functionResult = 2;
}

/**
 * The type of action described by the action proto.
 */
enum ContractActionType {
    /**
     * default non-value.
     */
    NoAction = 0;

    /**
     * Most CALL, CALLCODE, DELEGATECALL, and STATICCALL, and first action of ContractCall/ContractCallLocal to deployed
     * contracts. This does not include calls to system or precompiled contracts.
     */
    Call = 1;

    /**
     * CREATE, CREATE2, and first action of ContractCreate.
     */

    Create = 2;

    /**
     * like Call, but to precompiled contracts (0x1 to 0x9 as of Berlin)
     */
    Precompile = 3;

    /**
     * Call, but to system contract like HTS or ERC20 facades over Token accounts
     */
    System = 4;
}

/**
 * A finder grained action with a function result. Sometimes called "internal transactions." The function call itself
 * will be the first action in a list, followed by sub-action in the order they were executed.
 */
message ContractAction {

    /**
     * The type of this action.
     */
    ContractActionType callType = 1;

    /**
     * Only the first action can come from an account, the rest will come from contracts.  Because of DELEGATECALL
     * and CALLCODE the caller of actions whose parent is an account may also be an account.
     */
    oneof caller {
        /**
         * If the caller was a regular account, the AccountID.
         */
        AccountID callingAccount = 2;

        /**
         * If the caller was a smart contract account, the ContractID.
         */
        ContractID callingContract = 3;
    }

    /**
     * Gas given to this action, the upper limit of gas this action can spend.
     */
    uint64 gas = 4;

    /**
     * Bytes passed in as input data to this action.
     */
    bytes input = 5;

    /**
     * Who this action is directed to.
     */
    oneof recipient {
        /**
         * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
         * effects should be expected.
         */
        AccountID recipientAccount = 6;

        /**
         * The ContractID of the recipient if the recipient is a smart contract.
         */
        ContractID recipientContract = 7;

        /**
         * If the action was directed at an invalid solidity address, what that address was.
         */
        bytes invalidSolidityAddress = 8;
    }

    /**
     * The value (int tinybars) that is associated with this action.
     */
    int64 value = 9;

    /**
     * The actual gas spent by this action.
     */
    uint64 gasUsed = 10;

    /**
     * Was the action successful?
     */
    bool success = 11;

    /**
     * The result data of the action.
     */
    oneof resultData {

        /**
         * If successful, the output bytes of the action.
         */
        bytes output = 12;

        /**
         * The contract itself cause the transaction to fail via the `REVERT` operation
         */
        bytes revertReason = 13;

        /**
         * The transaction itself failed without an explicit `REVERT`
         */
        bytes error = 14;
    }

    /**
     * The nesting depth of this call. The original action is at depth=0.
     */
    uint32 callDepth = 15;
}

/**
 * The storage changes to a smart contract's storage as a side effect of the function call.
 */
message ContractStateChange {

    /**
     * The contract to which the storage changes apply to
     */
    ContractID contractID = 1;

    /**
     * The list of storage changes.
     */
    repeated StorageChange storageChanges = 2;
}

/**
 * A storage slot change description.
 */
message StorageChange {
    /**
     * The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed.
     */
    bytes slot = 1;

    /**
     * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
     *
     * Because of the way SSTORE operations are charged the slot is always read before being written to.
     */
    bytes valueRead = 2;

    /**
     * What the write mode is, either a read-only access or the updated value.
     */
    oneof writeMode {
        /**
         * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         */
        bytes valueWritten = 3;

        /**
         * If the value was only read this will be true, in lieu of valueWritten.
         */
        bool readOnly = 4;
    }
}